"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FeatureAppLoader = void 0;
const React = __importStar(require("react"));
const feature_hub_context_1 = require("./feature-hub-context");
const internal_feature_app_container_1 = require("./internal/internal-feature-app-container");
const prepend_base_url_1 = require("./internal/prepend-base-url");
const inBrowser = typeof window === 'object' &&
    typeof document === 'object' &&
    document.nodeType === 9;
class InternalFeatureAppLoader extends React.PureComponent {
    constructor(props) {
        super(props);
        this.state = {};
        this.errorHandled = false;
        this.mounted = false;
        const { baseUrl, featureAppManager, src: clientSrc, serverSrc, asyncSsrManager, addUrlForHydration, addStylesheetsForSsr, moduleType: clientModuleType, serverModuleType, } = props;
        const src = inBrowser ? clientSrc : serverSrc;
        const moduleType = inBrowser ? clientModuleType : serverModuleType;
        if (!src) {
            if (inBrowser) {
                throw new Error('No src provided.');
            }
            return;
        }
        if (!inBrowser && addUrlForHydration) {
            addUrlForHydration((0, prepend_base_url_1.prependBaseUrl)(baseUrl, clientSrc), clientModuleType);
        }
        if (!inBrowser && addStylesheetsForSsr) {
            const css = this.prependCssHrefs();
            if (css) {
                addStylesheetsForSsr(css);
            }
        }
        const url = (0, prepend_base_url_1.prependBaseUrl)(baseUrl, src);
        const { error, promise: loadingPromise, value: featureAppDefinition, } = featureAppManager.getAsyncFeatureAppDefinition(url, moduleType);
        if (error) {
            this.handleError(error);
            this.state = { error };
        }
        else if (featureAppDefinition) {
            this.state = { featureAppDefinition };
        }
        else if (!inBrowser && asyncSsrManager) {
            asyncSsrManager.scheduleRerender(loadingPromise);
        }
    }
    async componentDidMount() {
        this.mounted = true;
        this.appendCss();
        if (this.state.featureAppDefinition) {
            return;
        }
        const { baseUrl, featureAppManager, src, moduleType } = this.props;
        try {
            const featureAppDefinition = await featureAppManager.getAsyncFeatureAppDefinition((0, prepend_base_url_1.prependBaseUrl)(baseUrl, src), moduleType).promise;
            if (this.mounted) {
                this.setState({ featureAppDefinition });
            }
        }
        catch (error) {
            try {
                this.handleError(error);
                if (this.mounted) {
                    this.setState({ error });
                }
            }
            catch (handlerError) {
                if (this.mounted) {
                    this.setState({ error: handlerError, failedToHandleAsyncError: true });
                }
            }
        }
    }
    componentWillUnmount() {
        this.mounted = false;
    }
    render() {
        const { baseUrl, beforeCreate, children, config, featureAppId, featureAppName, onError, done, featureAppManager, logger, } = this.props;
        const { error, failedToHandleAsyncError, featureAppDefinition } = this.state;
        if (error) {
            if (failedToHandleAsyncError) {
                throw error;
            }
            if (children) {
                return children({ error, loading: false });
            }
            return null;
        }
        if (!featureAppDefinition && !children) {
            return null;
        }
        return (React.createElement(internal_feature_app_container_1.InternalFeatureAppContainer, { children: children, baseUrl: baseUrl, beforeCreate: beforeCreate, config: config, featureAppId: featureAppId, featureAppName: featureAppName, featureAppDefinition: featureAppDefinition, onError: onError, done: done, featureAppManager: featureAppManager, logger: logger }));
    }
    appendCss() {
        const css = this.prependCssHrefs();
        if (!css) {
            return;
        }
        for (const { href, media = 'all' } of css) {
            if (!document.querySelector(`link[href="${href}"]`)) {
                document.head.appendChild(Object.assign(document.createElement('link'), {
                    rel: 'stylesheet',
                    href,
                    media,
                }));
            }
        }
    }
    prependCssHrefs() {
        const { baseUrl, css } = this.props;
        if (!baseUrl || !css) {
            return css;
        }
        return css.map(({ href, media }) => ({
            href: (0, prepend_base_url_1.prependBaseUrl)(baseUrl, href),
            media,
        }));
    }
    handleError(error) {
        if (this.errorHandled) {
            return;
        }
        this.errorHandled = true;
        if (this.props.onError) {
            this.props.onError(error);
        }
        else {
            this.logError(error);
        }
    }
    logError(error) {
        const { baseUrl, featureAppId, logger, src: clientSrc, serverSrc, } = this.props;
        const src = inBrowser ? clientSrc : serverSrc;
        logger.error(`The Feature App for the src ${JSON.stringify(src && (0, prepend_base_url_1.prependBaseUrl)(baseUrl, src))} and the ID ${JSON.stringify(featureAppId)} could not be rendered.`, error);
    }
}
/**
 * The `FeatureAppLoader` component allows the integrator to load Feature Apps
 * from a remote location. It can also be used by a Feature App to render
 * another Feature App as a child.
 *
 * When a Feature App throws an error while rendering or, in the case of a
 * [[ReactFeatureApp]], throws an error in a lifecycle method, the
 * `FeatureAppLoader` renders `null`. On the server, however, rendering
 * errors are not caught and must therefore be handled by the integrator.
 */
function FeatureAppLoader(props) {
    return (React.createElement(feature_hub_context_1.FeatureHubContextConsumer, null, (featureHubContextValue) => (React.createElement(InternalFeatureAppLoader, Object.assign({}, featureHubContextValue, props)))));
}
exports.FeatureAppLoader = FeatureAppLoader;
//# sourceMappingURL=feature-app-loader.js.map