import { FeatureAppDefinition, FeatureAppEnvironment, FeatureServices, Logger } from '@feature-hub/core';
import * as React from 'react';
import { CustomFeatureAppRenderingParams, FeatureApp } from '../feature-app-container';
import { FeatureHubContextConsumerValue } from '../feature-hub-context';
export declare const handleError: (logger: Logger, error: unknown, onError?: ((e: unknown) => void) | undefined) => void;
export interface FeatureAppDescriptor {
    /**
     * The Feature App ID is used to identify the Feature App instance. Multiple
     * Feature App Loaders with the same `featureAppId` will render the same
     * Feature app instance. The ID is also used as a consumer ID for dependent
     * Feature Services. To render multiple instances of the same kind of Feature
     * App, different IDs must be used.
     */
    readonly featureAppId: string;
    /**
     * The Feature App's name. In contrast to the `featureAppId`, the name must
     * not be unique. It can be used by required Feature Services for display
     * purposes, logging, looking up Feature App configuration meta data, etc.
     */
    readonly featureAppName?: string;
}
export interface BaseFeatureAppContainerProps<TFeatureApp, TFeatureServices extends FeatureServices = FeatureServices, TConfig = unknown> extends FeatureAppDescriptor {
    /**
     * The absolute or relative base URL of the Feature App's assets and/or BFF.
     */
    readonly baseUrl?: string;
    /**
     * The consumer definition of the Feature App.
     */
    readonly featureAppDefinition?: FeatureAppDefinition<TFeatureApp, TFeatureServices, TConfig>;
    /**
     * A config object that is passed to the Feature App's `create` method.
     */
    readonly config?: TConfig;
    /**
     * A callback that is called before the Feature App is created.
     */
    readonly beforeCreate?: (env: FeatureAppEnvironment<TFeatureServices, TConfig>) => void;
    /**
     * A callback that is passed to the Feature App's `create` method. A
     * short-lived Feature App can call this function when it has completed its
     * task. The Integrator (or parent Feature App) can then decide to e.g.
     * unmount the Feature App.
     *
     * Optionally, the Feature App can pass a result into the done callback. The
     * type/structure of the result must be agreed between the Integrator (or
     * parent Feature App) and the Feature App.
     */
    readonly done?: (result?: unknown) => void;
    readonly onError?: (error: unknown) => void;
    /**
     * A children function can be provided to customize rendering of the
     * Feature App and provide Error or Loading UIs.
     */
    readonly children?: (params: CustomFeatureAppRenderingParams) => React.ReactNode;
}
export type InternalFeatureAppContainerProps<TFeatureApp, TFeatureServices extends FeatureServices, TConfig> = BaseFeatureAppContainerProps<TFeatureApp, TFeatureServices, TConfig> & Pick<FeatureHubContextConsumerValue, 'featureAppManager' | 'logger'> & {
    readonly parentFeatureApp?: FeatureAppDescriptor;
};
interface InternalFeatureAppContainerState<TFeatureApp extends FeatureApp> {
    readonly error?: unknown;
    readonly featureApp?: TFeatureApp;
    readonly release?: () => void;
    readonly failedToHandleAsyncError?: boolean;
    /**
     * If no loading promise was given, "loading" should always be false.
     */
    readonly loading: boolean;
}
export declare class InternalFeatureAppContainer<TFeatureApp extends FeatureApp, TFeatureServices extends FeatureServices = FeatureServices, TConfig = unknown> extends React.PureComponent<InternalFeatureAppContainerProps<TFeatureApp, TFeatureServices, TConfig>, InternalFeatureAppContainerState<TFeatureApp>> {
    static getDerivedStateFromProps(props: InternalFeatureAppContainerProps<unknown, FeatureServices, unknown>, state: InternalFeatureAppContainerState<FeatureApp>): Partial<InternalFeatureAppContainerState<FeatureApp>> | null;
    state: InternalFeatureAppContainerState<TFeatureApp>;
    private readonly containerRef;
    private mounted;
    private loadingPromiseHandled;
    private domFeatureAppAttached;
    componentDidCatch(error: unknown): void;
    componentDidMount(): void;
    componentDidUpdate(): void;
    componentWillUnmount(): void;
    render(): React.ReactNode;
    private handleLoading;
    private renderError;
    private handleError;
    private attachDomFeatureApp;
}
export {};
//# sourceMappingURL=internal-feature-app-container.d.ts.map