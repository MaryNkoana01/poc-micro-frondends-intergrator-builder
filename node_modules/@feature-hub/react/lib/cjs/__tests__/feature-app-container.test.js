"use strict";
/**
 * @jest-environment jsdom
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const React = __importStar(require("react"));
const react_test_renderer_1 = __importDefault(require("react-test-renderer"));
const __1 = require("..");
const internal_feature_app_container_1 = require("../internal/internal-feature-app-container");
const logger_1 = require("./logger");
const test_error_boundary_1 = require("./test-error-boundary");
describe('FeatureAppContainer', () => {
    let mockFeatureAppManager;
    let mockCreateFeatureAppScope;
    let mockFeatureAppDefinition;
    let mockFeatureAppScope;
    let consoleErrorSpy;
    const noErrorBoundaryConsoleErrorCalls = [
        [
            expect.stringContaining('Consider adding an error boundary to your tree to customize error handling behavior.'),
        ],
    ];
    const usingTestErrorBoundaryConsoleErrorCalls = [
        [
            expect.stringContaining('React will try to recreate this component tree from scratch using the error boundary you provided, TestErrorBoundary.'),
        ],
    ];
    const expectConsoleErrorCalls = (expectedConsoleErrorCalls) => {
        try {
            expect(consoleErrorSpy.mock.calls).toEqual(expectedConsoleErrorCalls);
        }
        finally {
            consoleErrorSpy.mockClear();
        }
    };
    beforeAll(() => {
        window.addEventListener('error', (e) => {
            // Prevent JSDOM from messing with the errors. See also:
            // https://github.com/jestjs/jest/issues/5223#issuecomment-355440432
            e.preventDefault();
        });
    });
    beforeEach(() => {
        consoleErrorSpy = jest.spyOn(console, 'error');
        mockFeatureAppDefinition = { create: jest.fn() };
        mockFeatureAppScope = { featureApp: {}, release: jest.fn() };
        mockCreateFeatureAppScope = jest.fn(() => (Object.assign({}, mockFeatureAppScope)));
        mockFeatureAppManager = {
            getAsyncFeatureAppDefinition: jest.fn(),
            createFeatureAppScope: mockCreateFeatureAppScope,
            preloadFeatureApp: jest.fn(),
        };
    });
    afterEach(() => {
        expect(consoleErrorSpy).not.toHaveBeenCalled();
        consoleErrorSpy.mockRestore();
    });
    it('throws an error when rendered without a FeatureHubContextProvider', () => {
        expect(() => react_test_renderer_1.default.create(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition }))).toThrowError(new Error('No Feature Hub context was provided! There are two possible causes: 1.) No FeatureHubContextProvider was rendered in the React tree. 2.) A Feature App that renders itself a FeatureAppLoader or a FeatureAppContainer did not declare @feature-hub/react as an external package.'));
        expectConsoleErrorCalls(noErrorBoundaryConsoleErrorCalls);
    });
    const renderWithFeatureHubContext = (node, { customLogger = true, testRendererOptions, } = {}) => react_test_renderer_1.default.create(React.createElement(__1.FeatureHubContextProvider, { value: {
            featureAppManager: mockFeatureAppManager,
            logger: customLogger ? logger_1.logger : undefined,
        } }, node), testRendererOptions);
    it('calls the Feature App manager with the given featureAppDefinition, featureAppId, config, baseUrl, beforeCreate callback, and done callback', () => {
        const mockBeforeCreate = jest.fn();
        const mockDone = jest.fn();
        renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppDefinition: mockFeatureAppDefinition, featureAppId: "testId", config: "testConfig", baseUrl: "/base", beforeCreate: mockBeforeCreate, done: mockDone }));
        expect(mockCreateFeatureAppScope.mock.calls).toEqual([
            [
                'testId',
                mockFeatureAppDefinition,
                {
                    baseUrl: '/base',
                    config: 'testConfig',
                    beforeCreate: mockBeforeCreate,
                    done: mockDone,
                },
            ],
        ]);
    });
    describe('with a React Feature App', () => {
        beforeEach(() => {
            mockFeatureAppScope = {
                featureApp: {
                    render: () => React.createElement("div", null, "This is the React Feature App."),
                },
                release: jest.fn(),
            };
        });
        it('renders the React element', () => {
            const testRenderer = renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition }));
            expect(testRenderer.toJSON()).toMatchInlineSnapshot(`
<div>
  This is the React Feature App.
</div>
`);
        });
        describe('when children function is provided', () => {
            it('passes react node to children function', () => {
                const children = jest.fn(({ featureAppNode }) => (React.createElement("div", { id: "children-wrap" }, featureAppNode)));
                const testRenderer = renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition, children: children }));
                expect(children).toHaveBeenCalledTimes(1);
                expect(children.mock.calls[0][0]).toMatchInlineSnapshot(`
          {
            "featureAppNode": <div>
              This is the React Feature App.
            </div>,
            "loading": false,
          }
        `);
                expect(testRenderer.toJSON()).toMatchInlineSnapshot(`
          <div
            id="children-wrap"
          >
            <div>
              This is the React Feature App.
            </div>
          </div>
        `);
            });
        });
        describe('when the Feature App renders another Feature App', () => {
            beforeEach(() => {
                let didRenderChildFeatureApp = false;
                mockFeatureAppScope = {
                    featureApp: {
                        render: () => {
                            if (didRenderChildFeatureApp) {
                                return React.createElement("div", null, "Child");
                            }
                            didRenderChildFeatureApp = true;
                            return (React.createElement(__1.FeatureAppContainer, { featureAppId: "childTestId", featureAppDefinition: mockFeatureAppDefinition }));
                        },
                    },
                    release: jest.fn(),
                };
            });
            it('passes the parent Feature App descriptor to `createFeatureAppScope`', () => {
                const testRenderer = renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "parentTestId", featureAppName: "parentTestName", featureAppDefinition: mockFeatureAppDefinition }));
                expect(mockCreateFeatureAppScope.mock.calls).toEqual([
                    [
                        'parentTestId',
                        mockFeatureAppDefinition,
                        { featureAppName: 'parentTestName' },
                    ],
                    [
                        'childTestId',
                        mockFeatureAppDefinition,
                        {
                            parentFeatureApp: {
                                featureAppId: 'parentTestId',
                                featureAppName: 'parentTestName',
                            },
                        },
                    ],
                ]);
                expect(testRenderer.toJSON()).toMatchInlineSnapshot(`
  <div>
    Child
  </div>
`);
            });
        });
        describe('when the Feature App throws in render', () => {
            let mockError;
            beforeEach(() => {
                mockError = new Error('Failed to render.');
                mockFeatureAppScope = Object.assign(Object.assign({}, mockFeatureAppScope), { featureApp: {
                        render: () => {
                            throw mockError;
                        },
                    } });
            });
            it("doesn't throw an error", () => {
                expect(() => {
                    renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition }));
                }).not.toThrow();
            });
            it('logs the error', () => {
                renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition }));
                expect(logger_1.logger.error.mock.calls).toEqual([[mockError]]);
            });
            describe('with onError provided', () => {
                it('calls onError with the error', () => {
                    const onError = jest.fn();
                    renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition, onError: onError }));
                    expect(onError.mock.calls).toEqual([[mockError]]);
                });
                it('does not log the error', () => {
                    renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition, onError: jest.fn() }));
                    expect(logger_1.logger.error).not.toHaveBeenCalled();
                });
                describe('when onError throws an error', () => {
                    let onErrorMockError;
                    beforeEach(() => {
                        onErrorMockError = new Error('Throwing in onError.');
                    });
                    it('re-throws the error', () => {
                        expect(() => renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition, onError: () => {
                                throw onErrorMockError;
                            } }))).toThrowError(onErrorMockError);
                        expectConsoleErrorCalls(noErrorBoundaryConsoleErrorCalls);
                    });
                });
            });
            describe('with a children function provided', () => {
                it('calls the children function with the error and loading=false', () => {
                    const children = jest.fn((_) => null);
                    renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition, children: children }));
                    expect(children.mock.calls).toEqual([
                        [
                            {
                                featureAppNode: undefined,
                                loading: false,
                                error: mockError,
                            },
                        ],
                    ]);
                });
                it('renders what the children function returns', () => {
                    const testRenderer = renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition, children: () => 'Custom Error UI' }));
                    expect(testRenderer.toJSON()).toBe('Custom Error UI');
                });
                it('renders what the children function returns if feature app definition is undefined', () => {
                    const testRenderer = renderWithFeatureHubContext(React.createElement(internal_feature_app_container_1.InternalFeatureAppContainer, { featureAppId: "testId", children: () => 'loading UI', logger: logger_1.logger, featureAppManager: mockFeatureAppManager }));
                    expect(testRenderer.toJSON()).toBe('loading UI');
                });
                describe('when children throws an error', () => {
                    let childrenMockError;
                    beforeEach(() => {
                        childrenMockError = new Error('Throwing in children.');
                    });
                    it('re-throws the error', () => {
                        expect(() => renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition, children: () => {
                                throw childrenMockError;
                            } }))).toThrowError(childrenMockError);
                        expectConsoleErrorCalls(noErrorBoundaryConsoleErrorCalls);
                    });
                });
            });
        });
        describe('when the Feature App throws in componentDidMount', () => {
            let mockError;
            beforeEach(() => {
                mockError = new Error('Failed to mount.');
                class FeatureAppComponent extends React.Component {
                    componentDidMount() {
                        throw mockError;
                    }
                    render() {
                        return React.createElement("p", null, "Markup");
                    }
                }
                mockFeatureAppScope = Object.assign(Object.assign({}, mockFeatureAppScope), { featureApp: {
                        render: () => React.createElement(FeatureAppComponent, null),
                    } });
            });
            it("doesn't throw an error", () => {
                expect(() => {
                    renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition }));
                }).not.toThrow();
            });
            it('logs the error', () => {
                renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition }));
                expect(logger_1.logger.error.mock.calls).toEqual([[mockError]]);
            });
            describe('with onError provided', () => {
                it('calls onError with the error', () => {
                    const onError = jest.fn();
                    renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition, onError: onError }));
                    expect(onError.mock.calls).toEqual([[mockError]]);
                });
                it('does not log the error', () => {
                    renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition, onError: jest.fn() }));
                    expect(logger_1.logger.error).not.toHaveBeenCalled();
                });
                describe('when onError throws an error', () => {
                    let onErrorMockError;
                    beforeEach(() => {
                        onErrorMockError = new Error('Throwing in onError.');
                    });
                    it('re-throws the error', () => {
                        expect(() => renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition, onError: () => {
                                throw onErrorMockError;
                            } }))).toThrowError(onErrorMockError);
                        expectConsoleErrorCalls([
                            [onErrorMockError],
                            ...noErrorBoundaryConsoleErrorCalls,
                        ]);
                    });
                });
            });
        });
        describe('when unmounted', () => {
            it('calls release() on the Feature App scope', () => {
                const testRenderer = renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition }));
                expect(mockFeatureAppScope.release).not.toHaveBeenCalled();
                testRenderer.unmount();
                expect(mockFeatureAppScope.release).toHaveBeenCalledTimes(1);
            });
            describe('when the Feature App scope throws an error while being destroyed', () => {
                let mockError;
                beforeEach(() => {
                    mockError = new Error('Failed to release Feature App');
                    mockFeatureAppScope.release = () => {
                        throw mockError;
                    };
                });
                it('logs the error', () => {
                    const testRenderer = renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition }));
                    testRenderer.unmount();
                    expect(logger_1.logger.error.mock.calls).toEqual([[mockError]]);
                });
                describe('with onError provided', () => {
                    it('calls onError with the error', () => {
                        const onError = jest.fn();
                        const testRenderer = renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition, onError: onError }));
                        testRenderer.unmount();
                        expect(onError.mock.calls).toEqual([[mockError]]);
                    });
                    it('does not log the error', () => {
                        const testRenderer = renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition, onError: jest.fn() }));
                        testRenderer.unmount();
                        expect(logger_1.logger.error).not.toHaveBeenCalled();
                    });
                    describe('when onError throws an error', () => {
                        let onErrorMockError;
                        beforeEach(() => {
                            onErrorMockError = new Error('Throwing in onError.');
                        });
                        it('re-throws the error', () => {
                            const testRenderer = renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition, onError: () => {
                                    throw onErrorMockError;
                                } }));
                            expect(() => testRenderer.unmount()).toThrowError(onErrorMockError);
                            expectConsoleErrorCalls([
                                [onErrorMockError],
                                ...noErrorBoundaryConsoleErrorCalls,
                            ]);
                        });
                    });
                });
            });
        });
        describe('when a feature app has a loading promise', () => {
            let resolveLoadingPromise;
            let rejectLoadingPromise;
            beforeEach(() => {
                const loadingPromise = new Promise((resolve, reject) => {
                    resolveLoadingPromise = async () => {
                        resolve();
                        // promise returns itself so we don't forget to await next
                        // async tick in tests
                        return loadingPromise;
                    };
                    rejectLoadingPromise = async (e) => {
                        reject(e);
                        return loadingPromise.catch(() => undefined);
                    };
                });
                mockFeatureAppScope = Object.assign(Object.assign({}, mockFeatureAppScope), { featureApp: {
                        render: () => (React.createElement("div", null, "This is the React Feature App with a loading promise.")),
                        loadingPromise,
                    } });
            });
            describe('when no children function is passed', () => {
                describe('when no feature app definition is passed', () => {
                    it('renders null', () => {
                        const testRenderer = renderWithFeatureHubContext(React.createElement(internal_feature_app_container_1.InternalFeatureAppContainer, { featureAppId: "testId", logger: logger_1.logger, featureAppManager: mockFeatureAppManager }));
                        expect(testRenderer.getInstance()).toBeNull();
                    });
                });
                describe('when the promise resolves', () => {
                    it('renders the feature app', async () => {
                        const testRenderer = renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition }));
                        expect(testRenderer.toJSON()).toMatchInlineSnapshot(`
              <div>
                This is the React Feature App with a loading promise.
              </div>
            `);
                        await resolveLoadingPromise();
                        expect(testRenderer.toJSON()).toMatchInlineSnapshot(`
              <div>
                This is the React Feature App with a loading promise.
              </div>
            `);
                    });
                });
                describe('when the promise rejects', () => {
                    let loadingPromiseMockError;
                    beforeEach(() => {
                        loadingPromiseMockError = new Error('loading promise rejected with error');
                    });
                    describe('with no onError', () => {
                        it('does not throw, but logs the error', async () => {
                            renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition }));
                            await rejectLoadingPromise(loadingPromiseMockError);
                            expect(logger_1.logger.error.mock.calls).toEqual([
                                [loadingPromiseMockError],
                            ]);
                        });
                    });
                    describe('with onError', () => {
                        it('calls onError', async () => {
                            const onError = jest.fn();
                            renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition, onError: onError }));
                            await rejectLoadingPromise(loadingPromiseMockError);
                            expect(onError).toHaveBeenCalledWith(loadingPromiseMockError);
                        });
                        describe('when unmounted before loading promise is rejected', () => {
                            it('calls onError with the error', async () => {
                                const onError = jest.fn();
                                const testRenderer = renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition, onError: onError }));
                                expect(onError.mock.calls).toEqual([]);
                                testRenderer.unmount();
                                expect(onError.mock.calls).toEqual([]);
                                await rejectLoadingPromise(loadingPromiseMockError);
                                expect(onError.mock.calls).toEqual([[loadingPromiseMockError]]);
                            });
                        });
                        describe('when onError throws an error', () => {
                            let onErrorMockError;
                            beforeEach(() => {
                                onErrorMockError = new Error('Throwing in onError.');
                            });
                            it('throws the error in render', async () => {
                                const handleError = jest.fn();
                                const testRenderer = renderWithFeatureHubContext(React.createElement(test_error_boundary_1.TestErrorBoundary, { handleError: handleError },
                                    React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition, onError: () => {
                                            throw onErrorMockError;
                                        } })));
                                expectConsoleErrorCalls([]);
                                await rejectLoadingPromise(loadingPromiseMockError);
                                expect(handleError.mock.calls).toEqual([[onErrorMockError]]);
                                expect(testRenderer.toJSON()).toBe('test error boundary');
                                expectConsoleErrorCalls(usingTestErrorBoundaryConsoleErrorCalls);
                            });
                            describe('when unmounted before loading promise is rejected', () => {
                                it('calls onError with the loading promise error', async () => {
                                    const onError = jest.fn(() => {
                                        throw onErrorMockError;
                                    });
                                    const testRenderer = renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition, onError: onError }));
                                    expect(onError.mock.calls).toEqual([]);
                                    testRenderer.unmount();
                                    expect(onError.mock.calls).toEqual([]);
                                    await rejectLoadingPromise(loadingPromiseMockError);
                                    expect(onError.mock.calls).toEqual([
                                        [loadingPromiseMockError],
                                    ]);
                                });
                            });
                        });
                    });
                });
            });
            describe('when children function is passed', () => {
                describe('when promise resolves', () => {
                    it('initially passes loading=true to children function, then loading=false', async () => {
                        const children = jest.fn((_) => null);
                        renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition, children: children }));
                        expect(children).toHaveBeenCalledTimes(1);
                        expect(children.mock.calls[0][0].loading).toBe(true);
                        await resolveLoadingPromise();
                        expect(children).toHaveBeenCalledTimes(2);
                        expect(children.mock.calls[1][0].loading).toBe(false);
                    });
                    it('renders what children returns', async () => {
                        const children = jest.fn(({ loading }) => (React.createElement("span", null, loading ? 'is loading' : 'not loading')));
                        const testRenderer = renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition, children: children }));
                        expect(testRenderer.toJSON()).toMatchInlineSnapshot(`
              <span>
                is loading
              </span>
            `);
                        await resolveLoadingPromise();
                        expect(testRenderer.toJSON()).toMatchInlineSnapshot(`
              <span>
                not loading
              </span>
            `);
                    });
                });
                describe('when promise rejects', () => {
                    let mockError;
                    beforeEach(() => {
                        mockError = new Error('loading promise rejected with error');
                    });
                    it('initially passes loading=true to children, then loading=false', async () => {
                        const children = jest.fn((_) => null);
                        renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition, children: children }));
                        expect(children).toHaveBeenCalledTimes(1);
                        expect(children.mock.calls[0][0].loading).toBe(true);
                        await rejectLoadingPromise(mockError);
                        expect(children).toHaveBeenCalledTimes(2);
                        expect(children.mock.calls[1][0].loading).toBe(false);
                    });
                    it('calls children with rejection error', async () => {
                        const children = jest.fn((_) => null);
                        renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition, children: children }));
                        expect(children).toHaveBeenCalledTimes(1);
                        expect(children.mock.calls[0][0].error).toBeUndefined();
                        await rejectLoadingPromise(mockError);
                        expect(children).toHaveBeenCalledTimes(2);
                        expect(children.mock.calls[1][0].error).toBe(mockError);
                    });
                    it(`doesn't pass featureAppNode to children after rejection`, async () => {
                        const children = jest.fn((_) => null);
                        renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition, children: children }));
                        expect(children).toHaveBeenCalledTimes(1);
                        expect(children.mock.calls[0][0].featureAppNode)
                            .toMatchInlineSnapshot(`
              <div>
                This is the React Feature App with a loading promise.
              </div>
            `);
                        await rejectLoadingPromise(mockError);
                        expect(children).toHaveBeenCalledTimes(2);
                        expect(children.mock.calls[1][0].featureAppNode).toBeUndefined();
                    });
                });
            });
            describe('when unmounted before loading promise is resolved', () => {
                it('does not try to set state', async () => {
                    const testRenderer = renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition }));
                    testRenderer.unmount();
                    await resolveLoadingPromise();
                    expect(consoleErrorSpy).not.toHaveBeenCalled();
                });
            });
        });
    });
    describe('with a DOM Feature App', () => {
        beforeEach(() => {
            mockFeatureAppScope = {
                featureApp: {
                    attachTo(container) {
                        container.innerHTML = 'This is the DOM Feature App.';
                    },
                },
                release: jest.fn(),
            };
        });
        it("renders a container and passes it to the Feature App's render method", () => {
            const mockSetInnerHtml = jest.fn();
            const testRenderer = renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition }), {
                testRendererOptions: {
                    createNodeMock: () => ({
                        set innerHTML(html) {
                            mockSetInnerHtml(html);
                        },
                    }),
                },
            });
            expect(testRenderer.toJSON()).toMatchInlineSnapshot(`<div />`);
            expect(mockSetInnerHtml).toHaveBeenCalledWith('This is the DOM Feature App.');
        });
        describe('when children function is provided', () => {
            it('passes react node to children function', () => {
                const mockSetInnerHtml = jest.fn();
                const children = jest.fn(({ featureAppNode }) => (React.createElement("div", { id: "children-wrap" }, featureAppNode)));
                const testRenderer = renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition, children: children }), {
                    testRendererOptions: {
                        createNodeMock: () => ({
                            set innerHTML(html) {
                                mockSetInnerHtml(html);
                            },
                        }),
                    },
                });
                expect(children).toHaveBeenCalledTimes(1);
                expect(children.mock.calls[0][0]).toMatchInlineSnapshot(`
          {
            "featureAppNode": <div />,
            "loading": false,
          }
        `);
                expect(mockSetInnerHtml).toHaveBeenCalledWith('This is the DOM Feature App.');
                expect(testRenderer.toJSON()).toMatchInlineSnapshot(`
          <div
            id="children-wrap"
          >
            <div />
          </div>
        `);
            });
        });
        describe('when a Feature App throws in attachTo', () => {
            let mockError;
            beforeEach(() => {
                mockError = new Error('Failed to attach.');
                mockFeatureAppScope = Object.assign(Object.assign({}, mockFeatureAppScope), { featureApp: {
                        attachTo: () => {
                            throw mockError;
                        },
                    } });
            });
            it("doesn't throw an error", () => {
                expect(() => renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition }), { testRendererOptions: { createNodeMock: () => ({}) } })).not.toThrowError(mockError);
            });
            it('logs the error', () => {
                renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition }), { testRendererOptions: { createNodeMock: () => ({}) } });
                expect(logger_1.logger.error.mock.calls).toEqual([[mockError]]);
            });
            describe('with an onError function provided', () => {
                it('calls the function with the error', () => {
                    const onError = jest.fn();
                    renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition, onError: onError }), { testRendererOptions: { createNodeMock: () => ({}) } });
                    expect(onError.mock.calls).toEqual([[mockError]]);
                });
                describe('when onError throws an error', () => {
                    let onErrorMockError;
                    beforeEach(() => {
                        onErrorMockError = new Error('Throwing in onError.');
                    });
                    it('re-throws the error', () => {
                        expect(() => renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition, onError: () => {
                                throw onErrorMockError;
                            } }), { testRendererOptions: { createNodeMock: () => ({}) } })).toThrowError(onErrorMockError);
                        expectConsoleErrorCalls([
                            [onErrorMockError],
                            ...noErrorBoundaryConsoleErrorCalls,
                        ]);
                    });
                });
            });
            describe('with a children function provided', () => {
                it('calls the function with the error', () => {
                    const children = jest.fn(({ featureAppNode }) => featureAppNode || null);
                    renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition, children: children }), { testRendererOptions: { createNodeMock: () => ({}) } });
                    expect(children).toHaveBeenLastCalledWith({
                        error: mockError,
                        loading: false,
                    });
                });
                it('renders the result of the function', () => {
                    const customErrorUI = 'custom error UI';
                    const children = jest.fn(({ featureAppNode }) => featureAppNode || customErrorUI);
                    const testRenderer = renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition, children: children }), { testRendererOptions: { createNodeMock: () => ({}) } });
                    expect(testRenderer.toJSON()).toBe(customErrorUI);
                });
            });
            describe('without a children function provided', () => {
                it('renders null', () => {
                    const testRenderer = renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition }), { testRendererOptions: { createNodeMock: () => ({}) } });
                    expect(testRenderer.toJSON()).toBeNull();
                });
            });
        });
        describe('when unmounted', () => {
            it('calls release() on the Feature App scope', () => {
                const testRenderer = renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition }));
                expect(mockFeatureAppScope.release).not.toHaveBeenCalled();
                testRenderer.unmount();
                expect(mockFeatureAppScope.release).toHaveBeenCalledTimes(1);
            });
            describe('when the Feature App scope throws an error while being released', () => {
                let mockError;
                beforeEach(() => {
                    mockError = new Error('Failed to release Feature App');
                    mockFeatureAppScope.release = () => {
                        throw mockError;
                    };
                });
                it('logs the error', () => {
                    const testRenderer = renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition }));
                    testRenderer.unmount();
                    expect(logger_1.logger.error.mock.calls).toEqual([[mockError]]);
                });
                describe('with an onError function provided', () => {
                    it('calls the function with the error', () => {
                        const onError = jest.fn();
                        const testRenderer = renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition, onError: onError }));
                        testRenderer.unmount();
                        expect(onError.mock.calls).toEqual([[mockError]]);
                    });
                });
            });
        });
    });
    for (const invalidFeatureApp of [
        undefined,
        null,
        {},
        { attachTo: 'foo' },
        { render: 'foo' },
    ]) {
        describe(`when an invalid Feature App (${JSON.stringify(invalidFeatureApp)}) is created`, () => {
            beforeEach(() => {
                mockFeatureAppScope = {
                    featureApp: invalidFeatureApp,
                    release: jest.fn(),
                };
            });
            it('renders nothing and logs an error', () => {
                const testRenderer = renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition }));
                expect(testRenderer.toJSON()).toBeNull();
                const expectedError = new Error('Invalid Feature App found. The Feature App must be an object with either 1) a `render` method that returns a React element, or 2) an `attachTo` method that accepts a container DOM element.');
                expect(logger_1.logger.error.mock.calls).toEqual([[expectedError]]);
            });
        });
    }
    describe('when a Feature App scope fails to be created', () => {
        let mockError;
        beforeEach(() => {
            mockError = new Error('Failed to create Feature App scope.');
            mockCreateFeatureAppScope.mockImplementation(() => {
                throw mockError;
            });
        });
        it('logs the creation error', () => {
            renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition }));
            expect(logger_1.logger.error.mock.calls).toEqual([[mockError]]);
        });
        describe('with an onError function provided', () => {
            it('calls the function with the error', () => {
                const onError = jest.fn();
                renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition, onError: onError }));
                expect(onError.mock.calls).toEqual([[mockError]]);
            });
            describe('when onError throws an error', () => {
                let onErrorMockError;
                beforeEach(() => {
                    onErrorMockError = new Error('Throwing in onError.');
                });
                it('re-throws the error', () => {
                    expect(() => renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition, onError: () => {
                            throw onErrorMockError;
                        } }))).toThrowError(onErrorMockError);
                    expectConsoleErrorCalls(noErrorBoundaryConsoleErrorCalls);
                });
            });
        });
        describe('when unmounted', () => {
            it('does nothing', () => {
                const testRenderer = renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition }));
                testRenderer.unmount();
            });
        });
    });
    describe('without a custom logger', () => {
        it('logs messages using the console', () => {
            const mockError = new Error('Failed to render.');
            mockFeatureAppScope = Object.assign(Object.assign({}, mockFeatureAppScope), { featureApp: {
                    render: () => {
                        throw mockError;
                    },
                } });
            renderWithFeatureHubContext(React.createElement(__1.FeatureAppContainer, { featureAppId: "testId", featureAppDefinition: mockFeatureAppDefinition }), { customLogger: false });
            expectConsoleErrorCalls([[mockError]]);
        });
    });
});
//# sourceMappingURL=feature-app-container.test.js.map