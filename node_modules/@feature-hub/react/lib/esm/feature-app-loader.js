import * as React from 'react';
import { FeatureHubContextConsumer, } from './feature-hub-context';
import { InternalFeatureAppContainer, } from './internal/internal-feature-app-container';
import { prependBaseUrl } from './internal/prepend-base-url';
const inBrowser = typeof window === 'object' &&
    typeof document === 'object' &&
    document.nodeType === 9;
class InternalFeatureAppLoader extends React.PureComponent {
    constructor(props) {
        super(props);
        this.state = {};
        this.errorHandled = false;
        this.mounted = false;
        const { baseUrl, featureAppManager, src: clientSrc, serverSrc, asyncSsrManager, addUrlForHydration, addStylesheetsForSsr, moduleType: clientModuleType, serverModuleType, } = props;
        const src = inBrowser ? clientSrc : serverSrc;
        const moduleType = inBrowser ? clientModuleType : serverModuleType;
        if (!src) {
            if (inBrowser) {
                throw new Error('No src provided.');
            }
            return;
        }
        if (!inBrowser && addUrlForHydration) {
            addUrlForHydration(prependBaseUrl(baseUrl, clientSrc), clientModuleType);
        }
        if (!inBrowser && addStylesheetsForSsr) {
            const css = this.prependCssHrefs();
            if (css) {
                addStylesheetsForSsr(css);
            }
        }
        const url = prependBaseUrl(baseUrl, src);
        const { error, promise: loadingPromise, value: featureAppDefinition, } = featureAppManager.getAsyncFeatureAppDefinition(url, moduleType);
        if (error) {
            this.handleError(error);
            this.state = { error };
        }
        else if (featureAppDefinition) {
            this.state = { featureAppDefinition };
        }
        else if (!inBrowser && asyncSsrManager) {
            asyncSsrManager.scheduleRerender(loadingPromise);
        }
    }
    async componentDidMount() {
        this.mounted = true;
        this.appendCss();
        if (this.state.featureAppDefinition) {
            return;
        }
        const { baseUrl, featureAppManager, src, moduleType } = this.props;
        try {
            const featureAppDefinition = await featureAppManager.getAsyncFeatureAppDefinition(prependBaseUrl(baseUrl, src), moduleType).promise;
            if (this.mounted) {
                this.setState({ featureAppDefinition });
            }
        }
        catch (error) {
            try {
                this.handleError(error);
                if (this.mounted) {
                    this.setState({ error });
                }
            }
            catch (handlerError) {
                if (this.mounted) {
                    this.setState({ error: handlerError, failedToHandleAsyncError: true });
                }
            }
        }
    }
    componentWillUnmount() {
        this.mounted = false;
    }
    render() {
        const { baseUrl, beforeCreate, children, config, featureAppId, featureAppName, onError, done, featureAppManager, logger, } = this.props;
        const { error, failedToHandleAsyncError, featureAppDefinition } = this.state;
        if (error) {
            if (failedToHandleAsyncError) {
                throw error;
            }
            if (children) {
                return children({ error, loading: false });
            }
            return null;
        }
        if (!featureAppDefinition && !children) {
            return null;
        }
        return (React.createElement(InternalFeatureAppContainer, { children: children, baseUrl: baseUrl, beforeCreate: beforeCreate, config: config, featureAppId: featureAppId, featureAppName: featureAppName, featureAppDefinition: featureAppDefinition, onError: onError, done: done, featureAppManager: featureAppManager, logger: logger }));
    }
    appendCss() {
        const css = this.prependCssHrefs();
        if (!css) {
            return;
        }
        for (const { href, media = 'all' } of css) {
            if (!document.querySelector(`link[href="${href}"]`)) {
                document.head.appendChild(Object.assign(document.createElement('link'), {
                    rel: 'stylesheet',
                    href,
                    media,
                }));
            }
        }
    }
    prependCssHrefs() {
        const { baseUrl, css } = this.props;
        if (!baseUrl || !css) {
            return css;
        }
        return css.map(({ href, media }) => ({
            href: prependBaseUrl(baseUrl, href),
            media,
        }));
    }
    handleError(error) {
        if (this.errorHandled) {
            return;
        }
        this.errorHandled = true;
        if (this.props.onError) {
            this.props.onError(error);
        }
        else {
            this.logError(error);
        }
    }
    logError(error) {
        const { baseUrl, featureAppId, logger, src: clientSrc, serverSrc, } = this.props;
        const src = inBrowser ? clientSrc : serverSrc;
        logger.error(`The Feature App for the src ${JSON.stringify(src && prependBaseUrl(baseUrl, src))} and the ID ${JSON.stringify(featureAppId)} could not be rendered.`, error);
    }
}
/**
 * The `FeatureAppLoader` component allows the integrator to load Feature Apps
 * from a remote location. It can also be used by a Feature App to render
 * another Feature App as a child.
 *
 * When a Feature App throws an error while rendering or, in the case of a
 * [[ReactFeatureApp]], throws an error in a lifecycle method, the
 * `FeatureAppLoader` renders `null`. On the server, however, rendering
 * errors are not caught and must therefore be handled by the integrator.
 */
export function FeatureAppLoader(props) {
    return (React.createElement(FeatureHubContextConsumer, null, (featureHubContextValue) => (React.createElement(InternalFeatureAppLoader, Object.assign({}, featureHubContextValue, props)))));
}
//# sourceMappingURL=feature-app-loader.js.map