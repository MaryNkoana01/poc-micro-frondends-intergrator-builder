{"version":3,"file":"feature-app-container.js","sourceRoot":"","sources":["../../src/feature-app-container.tsx"],"names":[],"mappings":"AACA,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;AAC/B,OAAO,EAAC,yBAAyB,EAAC,MAAM,uBAAuB,CAAC;AAChE,OAAO,EAAC,iBAAiB,EAAC,MAAM,gCAAgC,CAAC;AACjE,OAAO,EAEL,2BAA2B,GAC5B,MAAM,2CAA2C,CAAC;AAgGnD;;;;;;;;;GASG;AACH,MAAM,UAAU,mBAAmB,CAKjC,KAAuE;IAEvE,OAAO,CACL,oBAAC,yBAAyB,QACvB,CAAC,EAAC,iBAAiB,EAAE,MAAM,EAAC,EAAE,EAAE,CAAC,CAChC,oBAAC,iBAAiB,CAAC,QAAQ,QACxB,CAAC,gBAAgB,EAAE,EAAE,CAAC,CACrB,oBAAC,2BAA2B,kBAC1B,iBAAiB,EAAE,iBAAiB,EACpC,MAAM,EAAE,MAAM,EACd,gBAAgB,EAAE,gBAAgB,IAC9B,KAAK,EACT,CACH,CAC0B,CAC9B,CACyB,CAC7B,CAAC;AACJ,CAAC","sourcesContent":["import {FeatureAppDefinition, FeatureServices} from '@feature-hub/core';\nimport * as React from 'react';\nimport {FeatureHubContextConsumer} from './feature-hub-context';\nimport {FeatureAppContext} from './internal/feature-app-context';\nimport {\n  BaseFeatureAppContainerProps,\n  InternalFeatureAppContainer,\n} from './internal/internal-feature-app-container';\n\nexport interface BaseFeatureApp {\n  /**\n   * Client-side only: A Feature App can define a promise that is resolved when\n   * it is ready to render its content, e.g. after fetching required data\n   * first. If the integrator has defined a loading UI, it will be rendered\n   * until the promise is resolved.\n   * For a similar behaviour during server-side rendering, one must handle this\n   * using the async-ssr-manager.\n   */\n  readonly loadingPromise?: Promise<void>;\n}\n\n/**\n * The recommended way of writing a Feature App for a React integrator.\n */\nexport interface ReactFeatureApp extends BaseFeatureApp {\n  /**\n   * A React Feature App must define a `render` method that returns a React\n   * element. Since this element is directly rendered by React, the standard\n   * React lifecyle methods can be used (if `render` returns an instance of a\n   * React `ComponentClass`).\n   */\n  render(): React.ReactNode;\n}\n\n/**\n * A DOM Feature App allows the use of other frontend technologies such as\n * Vue.js or Angular, although it is placed on a web page using React.\n */\nexport interface DomFeatureApp extends BaseFeatureApp {\n  /**\n   * @param container The container element to which the Feature App can attach\n   * itself.\n   */\n  attachTo(container: Element): void;\n}\n\n/**\n * A Feature App that can be rendered by the [[FeatureAppLoader]] or\n * [[FeatureAppContainer]] must be either a [[ReactFeatureApp]]\n * (recommended) or a [[DomFeatureApp]].\n */\nexport type FeatureApp = ReactFeatureApp | DomFeatureApp;\n\nexport interface CustomFeatureAppRenderingParams {\n  /**\n   * The Feature App node is a rendered React node, that can be inserted into\n   * the react tree.\n   *\n   * **Caution!** If `featureAppNode` is defined it has to be rendered, even\n   * when `loading=true`. A Feature App might depend on being rendered before\n   * resolving its loading promise.\n   *\n   * **Caution!** The Feature App node should always be rendered into the same\n   * position of the tree. Otherwise React can re-mount the Feature App, which\n   * is resource-expensive and can break DOM Feature Apps.\n   */\n  featureAppNode?: React.ReactNode;\n\n  /**\n   * The Error can be used to render a custom error UI. If there is an error,\n   * the Feature App will stop rendering and `featureAppNode` is `undefined`.\n   */\n  error?: unknown;\n\n  /**\n   * The loading boolean indicates if the Feature App is still loading, and can\n   * be used to render a custom loading UI.\n   *\n   * **Caution!** If `featureAppNode` is defined it has to be rendered, even\n   * when `loading=true`. A Feature App might depend on being rendered before\n   * resolving its loading promise.\n   *\n   * To not show the Feature App in favour of a loading UI, it must be hidden\n   * visually (e.g. via `display: none;`).\n   */\n  loading: boolean;\n}\n\nexport interface FeatureAppContainerProps<\n  TFeatureApp,\n  TFeatureServices extends FeatureServices = FeatureServices,\n  TConfig = unknown,\n> extends BaseFeatureAppContainerProps<TFeatureApp, TFeatureServices, TConfig> {\n  /**\n   * The consumer definition of the Feature App.\n   */\n  readonly featureAppDefinition: FeatureAppDefinition<\n    TFeatureApp,\n    TFeatureServices,\n    TConfig\n  >;\n}\n\n/**\n * The `FeatureAppContainer` component allows the integrator to bundle Feature\n * Apps instead of loading them from a remote location. It can also be used by\n * a Feature App to render another Feature App as a child.\n *\n * When a Feature App throws an error while rendering or, in the case of a\n * [[ReactFeatureApp]], throws an error in a lifecycle method, the\n * `FeatureAppContainer` renders `null`. On the server, however, rendering\n * errors are not caught and must therefore be handled by the integrator.\n */\nexport function FeatureAppContainer<\n  TFeatureApp extends FeatureApp,\n  TFeatureServices extends FeatureServices = FeatureServices,\n  TConfig = unknown,\n>(\n  props: FeatureAppContainerProps<TFeatureApp, TFeatureServices, TConfig>,\n): JSX.Element {\n  return (\n    <FeatureHubContextConsumer>\n      {({featureAppManager, logger}) => (\n        <FeatureAppContext.Consumer>\n          {(parentFeatureApp) => (\n            <InternalFeatureAppContainer<TFeatureApp, TFeatureServices, TConfig>\n              featureAppManager={featureAppManager}\n              logger={logger}\n              parentFeatureApp={parentFeatureApp}\n              {...props}\n            />\n          )}\n        </FeatureAppContext.Consumer>\n      )}\n    </FeatureHubContextConsumer>\n  );\n}\n"]}