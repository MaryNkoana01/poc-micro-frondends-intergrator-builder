{"version":3,"file":"feature-app-manager.js","sourceRoot":"","sources":["../../src/feature-app-manager.ts"],"names":[],"mappings":"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","sourcesContent":["import {AsyncValue} from './async-value';\nimport {ExternalsValidator} from './externals-validator';\nimport {\n  FeatureServiceConsumerDefinition,\n  FeatureServiceProviderDefinition,\n  FeatureServiceRegistry,\n  FeatureServices,\n  SharedFeatureService,\n} from './feature-service-registry';\nimport * as Messages from './internal/feature-app-manager-messages';\nimport {isFeatureAppModule} from './internal/is-feature-app-module';\nimport {Logger} from './logger';\n\nexport interface FeatureAppDescriptor {\n  /**\n   * The ID that the integrator (or parent Feature App) has assigned to the\n   * Feature App instance.\n   */\n  readonly featureAppId: string;\n\n  /**\n   * The name that the integrator (or parent Feature App) might have assigned to\n   * the Feature App.\n   */\n  readonly featureAppName?: string;\n}\n\nexport interface FeatureAppEnvironment<\n  TFeatureServices extends FeatureServices,\n  TConfig,\n> extends FeatureAppDescriptor {\n  /**\n   * An object of required Feature Services that are semver-compatible with the\n   * declared dependencies in the Feature App definition.\n   */\n  readonly featureServices: TFeatureServices;\n\n  /**\n   * A config object that is provided by the integrator.\n   */\n  readonly config: TConfig | undefined;\n\n  /**\n   * The absolute or relative base URL of the Feature App's assets and/or BFF.\n   */\n  readonly baseUrl: string | undefined;\n\n  /**\n   * If this callback is defined, a short-lived Feature App can call this\n   * function when it has completed its task. The Integrator (or parent Feature\n   * App) can then decide to e.g. unmount the Feature App.\n   *\n   * Optionally, the Feature App can pass a result into the done callback. The\n   * type/structure of the result must be agreed between the Integrator (or\n   * parent Feature App) and the Feature App.\n   */\n  readonly done?: (result?: unknown) => void;\n}\n\nexport interface FeatureAppDefinition<\n  TFeatureApp,\n  TFeatureServices extends FeatureServices = FeatureServices,\n  TConfig = unknown,\n> extends FeatureServiceConsumerDefinition {\n  readonly ownFeatureServiceDefinitions?: FeatureServiceProviderDefinition<SharedFeatureService>[];\n\n  create(env: FeatureAppEnvironment<TFeatureServices, TConfig>): TFeatureApp;\n}\n\n/**\n * @param url A URL pointing to a [[FeatureAppDefinition]] bundle in a module\n * format compatible with the module loader.\n *\n * @param moduleType The module type of the [[FeatureAppDefinition]] bundle.\n * This can be used to choose different loading strategies based on the module\n * type of the Feature App.\n */\nexport type ModuleLoader = (\n  url: string,\n  moduleType?: string,\n) => Promise<unknown>;\n\nexport interface FeatureAppScope<TFeatureApp> {\n  readonly featureApp: TFeatureApp;\n\n  /**\n   * When the `FeatureAppScope` is not needed anymore, e.g. the Feature App is\n   * unmounted, `release` must be called. When all scopes for a Feature App ID\n   * have been released, the Feature App instance is destroyed.\n   */\n  release(): void;\n}\n\nexport interface FeatureAppScopeOptions<\n  TFeatureServices extends FeatureServices,\n  TConfig,\n> {\n  /**\n   * The Feature App's name. In contrast to the `featureAppId`, the name must\n   * not be unique. It can be used by required Feature Services for display\n   * purposes, logging, looking up Feature App configuration meta data, etc.\n   */\n  readonly featureAppName?: string;\n\n  /**\n   * The absolute or relative base URL of the Feature App's assets and/or BFF.\n   */\n  readonly baseUrl?: string;\n\n  /**\n   * A config object that is intended for a specific Feature App instance.\n   */\n  readonly config?: TConfig;\n\n  /**\n   * A callback that is called before the Feature App is created.\n   */\n  readonly beforeCreate?: (\n    env: FeatureAppEnvironment<TFeatureServices, TConfig>,\n  ) => void;\n\n  /**\n   * A callback that is passed to the Feature App's `create` method. A\n   * short-lived Feature App can call this function when it has completed its\n   * task. The Integrator (or parent Feature App) can then decide to e.g.\n   * unmount the Feature App.\n   *\n   * Optionally, the Feature App can pass a result into the done callback. The\n   * type/structure of the result must be agreed between the Integrator (or\n   * parent Feature App) and the Feature App.\n   */\n  readonly done?: (result?: unknown) => void;\n\n  /**\n   * If the Feature App is created in the context of another Feature App, the\n   * `parentFeatureApp` property should be populated accordingly. This allows\n   * the integrator to collect information about \"Feature App in Feature App\"\n   * usage.\n   */\n  readonly parentFeatureApp?: FeatureAppDescriptor;\n}\n\nexport interface OnBindParams extends FeatureAppDescriptor {\n  readonly featureAppDefinition: FeatureServiceConsumerDefinition;\n  readonly parentFeatureApp?: FeatureAppDescriptor;\n}\n\nexport interface FeatureAppManagerOptions {\n  /**\n   * For the `FeatureAppManager` to be able to load Feature Apps from a remote\n   * location, a module loader must be provided. This can either be one of the\n   * module loaders that are provided by @feature-hub, i.e.\n   * `@feature-hub/module-loader-amd`, `@feature-hub/module-loader-federation`,\n   * and `@feature-hub/module-loader-commonjs`, or a custom loader.\n   */\n  readonly moduleLoader?: ModuleLoader;\n\n  /**\n   * When using a [[moduleLoader]], it might make sense to validate\n   * external dependencies that are required by Feature Apps against the\n   * shared dependencies that are provided by the integrator. This makes it\n   * possible that an error is already thrown when creating a Feature App with\n   * incompatible external dependencies, and thus enables early feedback as to\n   * whether a Feature App is compatible with the integration environment.\n   */\n  readonly externalsValidator?: ExternalsValidator;\n\n  /**\n   * A custom logger that shall be used instead of `console`.\n   */\n  readonly logger?: Logger;\n\n  /**\n   * A function that is called for every Feature App when its dependent Feature\n   * Services are bound. This allows the integrator to collect information about\n   * Feature Service and Feature App usage.\n   */\n  readonly onBind?: (params: OnBindParams) => void;\n}\n\ntype FeatureAppId = string;\n\ninterface FeatureAppRetainer<TFeatureApp> {\n  readonly featureApp: TFeatureApp;\n  retain(): void;\n  release(): void;\n}\n\n/**\n * The `FeatureAppManager` manages the lifecycle of Feature Apps.\n */\nexport class FeatureAppManager {\n  private readonly asyncFeatureAppDefinitions = new Map<\n    string,\n    AsyncValue<FeatureAppDefinition<unknown>>\n  >();\n\n  private readonly featureAppDefinitionsWithRegisteredOwnFeatureServices =\n    new WeakSet<FeatureAppDefinition<unknown>>();\n\n  private readonly featureAppRetainers = new Map<\n    FeatureAppId,\n    FeatureAppRetainer<unknown>\n  >();\n\n  private readonly logger: Logger;\n\n  public constructor(\n    private readonly featureServiceRegistry: FeatureServiceRegistry,\n    private readonly options: FeatureAppManagerOptions = {},\n  ) {\n    this.logger = options.logger || console;\n  }\n\n  /**\n   * Load a [[FeatureAppDefinition]] using the module loader the\n   * [[FeatureAppManager]] was initilized with.\n   *\n   * @throws Throws an error if no module loader was provided on initilization.\n   *\n   * @param url A URL pointing to a [[FeatureAppDefinition]] bundle in a module\n   * format compatible with the module loader.\n   *\n   * @param moduleType The module type of the [[FeatureAppDefinition]] bundle.\n   * This value can be used by the provided\n   * [[FeatureAppManagerOptions.moduleLoader]].\n   *\n   * @returns An [[AsyncValue]] containing a promise that resolves with the\n   * loaded [[FeatureAppDefinition]]. If called again with the same URL it\n   * returns the same [[AsyncValue]]. The promise rejects when loading fails, or\n   * when the loaded bundle doesn't export a [[FeatureAppDefinition]] as\n   * default.\n   */\n  public getAsyncFeatureAppDefinition(\n    url: string,\n    moduleType?: string,\n  ): AsyncValue<FeatureAppDefinition<unknown>> {\n    const key = `${url}${moduleType}`;\n    let asyncFeatureAppDefinition = this.asyncFeatureAppDefinitions.get(key);\n\n    if (!asyncFeatureAppDefinition) {\n      asyncFeatureAppDefinition = this.createAsyncFeatureAppDefinition(\n        url,\n        moduleType,\n      );\n\n      this.asyncFeatureAppDefinitions.set(key, asyncFeatureAppDefinition);\n    }\n\n    return asyncFeatureAppDefinition;\n  }\n\n  /**\n   * Create a [[FeatureAppScope]] which includes validating externals, binding\n   * all available Feature Service dependencies, and calling the `create` method\n   * of the [[FeatureAppDefinition]].\n   *\n   * @throws Throws an error if Feature Services that the\n   * [[FeatureAppDefinition]] provides with its `ownFeatureServices` key fail to\n   * be registered.\n   * @throws Throws an error if the required externals can't be satisfied.\n   * @throws Throws an error if the required Feature Services can't be\n   * satisfied.\n   * @throws Throws an error the [[FeatureAppDefinition]]'s `create` method\n   * throws.\n   *\n   * @param featureAppID The ID of the Feature App to create a scope for.\n   * @param featureAppDefinition The definition of the Feature App to create a\n   * scope for.\n   *\n   * @returns A [[FeatureAppScope]] for the provided Feature App ID and\n   * [[FeatureAppDefinition]]. A new scope is created for every call of\n   * `createFeatureAppScope`, even with the same ID and definiton.\n   */\n  public createFeatureAppScope<\n    TFeatureApp,\n    TFeatureServices extends FeatureServices = FeatureServices,\n    TConfig = unknown,\n  >(\n    featureAppId: string,\n    featureAppDefinition: FeatureAppDefinition<\n      TFeatureApp,\n      TFeatureServices,\n      TConfig\n    >,\n    options: FeatureAppScopeOptions<TFeatureServices, TConfig> = {},\n  ): FeatureAppScope<TFeatureApp> {\n    const featureAppRetainer = this.getFeatureAppRetainer<\n      TFeatureApp,\n      TFeatureServices,\n      TConfig\n    >(featureAppId, featureAppDefinition, options);\n\n    let released = false;\n\n    return {\n      featureApp: featureAppRetainer.featureApp,\n\n      release: () => {\n        if (released) {\n          this.logger.warn(\n            `The Feature App with the ID ${JSON.stringify(\n              featureAppId,\n            )} has already been released for this scope.`,\n          );\n        } else {\n          released = true;\n          featureAppRetainer.release();\n        }\n      },\n    };\n  }\n\n  /**\n   * Preload a [[FeatureAppDefinition]] using the module loader the\n   * [[FeatureAppManager]] was initilized with. Useful before hydration of a\n   * server rendered page to avoid render result mismatch between client and\n   * server due missing [[FeatureAppDefinition]]s.\n   *\n   * @throws Throws an error if no module loader was provided on initilization.\n   *\n   * @param url A URL pointing to a [[FeatureAppDefinition]] bundle in a module\n   * format compatible with the module loader.\n   *\n   * @param moduleType The module type of the [[FeatureAppDefinition]] bundle.\n   * This value can be used by the provided\n   * [[FeatureAppManagerOptions.moduleLoader]].\n   */\n  public async preloadFeatureApp(\n    url: string,\n    moduleType?: string,\n  ): Promise<void> {\n    await this.getAsyncFeatureAppDefinition(url, moduleType).promise;\n  }\n\n  private createAsyncFeatureAppDefinition(\n    url: string,\n    moduleType?: string,\n  ): AsyncValue<FeatureAppDefinition<unknown>> {\n    const {moduleLoader: loadModule} = this.options;\n\n    if (!loadModule) {\n      throw new Error('No module loader provided.');\n    }\n\n    return new AsyncValue(\n      loadModule(url, moduleType).then((featureAppModule) => {\n        if (!isFeatureAppModule(featureAppModule)) {\n          throw new Error(\n            Messages.invalidFeatureAppModule(\n              url,\n              moduleType,\n              this.options.moduleLoader,\n            ),\n          );\n        }\n\n        this.logger.info(\n          `The Feature App module at the url ${JSON.stringify(\n            url,\n          )} has been successfully loaded.`,\n        );\n\n        return featureAppModule.default;\n      }),\n    );\n  }\n\n  private registerOwnFeatureServices(\n    featureAppId: string,\n    featureAppDefinition: FeatureAppDefinition<unknown>,\n  ): void {\n    if (\n      this.featureAppDefinitionsWithRegisteredOwnFeatureServices.has(\n        featureAppDefinition,\n      )\n    ) {\n      return;\n    }\n\n    if (featureAppDefinition.ownFeatureServiceDefinitions) {\n      this.featureServiceRegistry.registerFeatureServices(\n        featureAppDefinition.ownFeatureServiceDefinitions,\n        featureAppId,\n      );\n    }\n\n    this.featureAppDefinitionsWithRegisteredOwnFeatureServices.add(\n      featureAppDefinition,\n    );\n  }\n\n  private getFeatureAppRetainer<\n    TFeatureApp,\n    TFeatureServices extends FeatureServices = FeatureServices,\n    TConfig = unknown,\n  >(\n    featureAppId: string,\n    featureAppDefinition: FeatureAppDefinition<\n      TFeatureApp,\n      TFeatureServices,\n      TConfig\n    >,\n    options: FeatureAppScopeOptions<TFeatureServices, TConfig>,\n  ): FeatureAppRetainer<TFeatureApp> {\n    let featureAppRetainer = this.featureAppRetainers.get(featureAppId);\n\n    if (featureAppRetainer) {\n      featureAppRetainer.retain();\n    } else {\n      this.registerOwnFeatureServices(featureAppId, featureAppDefinition);\n\n      featureAppRetainer = this.createFeatureAppRetainer(\n        featureAppDefinition,\n        featureAppId,\n        options,\n      );\n    }\n\n    return featureAppRetainer as FeatureAppRetainer<TFeatureApp>;\n  }\n\n  private createFeatureAppRetainer<\n    TFeatureApp,\n    TFeatureServices extends FeatureServices,\n    TConfig,\n  >(\n    featureAppDefinition: FeatureAppDefinition<\n      TFeatureApp,\n      TFeatureServices,\n      TConfig\n    >,\n    featureAppId: string,\n    options: FeatureAppScopeOptions<TFeatureServices, TConfig>,\n  ): FeatureAppRetainer<TFeatureApp> {\n    this.validateExternals(featureAppDefinition, featureAppId);\n\n    const {\n      featureAppName,\n      baseUrl,\n      beforeCreate,\n      config,\n      done,\n      parentFeatureApp,\n    } = options;\n\n    const binding = this.featureServiceRegistry.bindFeatureServices(\n      featureAppDefinition,\n      featureAppId,\n      featureAppName,\n    );\n\n    try {\n      this.options.onBind?.({\n        featureAppDefinition,\n        featureAppId,\n        featureAppName,\n        parentFeatureApp,\n      });\n    } catch (error) {\n      this.logger.error('Failed to execute onBind callback.', error);\n    }\n\n    const env: FeatureAppEnvironment<TFeatureServices, TConfig> = {\n      baseUrl,\n      config,\n      featureAppId,\n      featureAppName,\n      featureServices: binding.featureServices as TFeatureServices,\n      done,\n    };\n\n    try {\n      beforeCreate?.(env);\n\n      const featureApp = featureAppDefinition.create(env);\n\n      this.logger.info(\n        `The Feature App with the ID ${JSON.stringify(\n          featureAppId,\n        )} has been successfully created.`,\n      );\n\n      let retainCount = 1;\n\n      const featureAppRetainer: FeatureAppRetainer<TFeatureApp> = {\n        featureApp,\n\n        retain: () => {\n          retainCount += 1;\n        },\n\n        release: () => {\n          retainCount -= 1;\n\n          if (retainCount === 0) {\n            this.featureAppRetainers.delete(featureAppId);\n            binding.unbind();\n          }\n        },\n      };\n\n      this.featureAppRetainers.set(featureAppId, featureAppRetainer);\n\n      return featureAppRetainer;\n    } catch (error) {\n      binding.unbind();\n\n      throw error;\n    }\n  }\n\n  private validateExternals(\n    featureAppDefinition: FeatureServiceConsumerDefinition,\n    featureAppId: string,\n  ): void {\n    const {externalsValidator} = this.options;\n\n    if (!externalsValidator) {\n      return;\n    }\n\n    const {dependencies} = featureAppDefinition;\n\n    if (dependencies && dependencies.externals) {\n      externalsValidator.validate(dependencies.externals, featureAppId);\n    }\n  }\n}\n"]}