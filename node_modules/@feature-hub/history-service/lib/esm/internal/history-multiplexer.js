import * as history from 'history';
import { createHistoryPath } from './create-history-path';
import { createKey } from './create-key';
export class HistoryMultiplexer {
    constructor(rootHistory, rootLocationTransformer) {
        this.rootHistory = rootHistory;
        this.rootLocationTransformer = rootLocationTransformer;
        this.rootHistoryV2 = {
            get length() {
                try {
                    return window.history.length;
                }
                catch (_a) {
                    return 1;
                }
            },
            get location() {
                return rootHistory.location;
            },
            push(location) {
                const { pathname, search, hash, state } = location;
                rootHistory.push({ pathname, search, hash }, state);
            },
            replace(location) {
                const { pathname, search, hash, state } = location;
                rootHistory.replace({ pathname, search, hash }, state);
            },
            createHref(location) {
                return rootHistory.createHref(location);
            },
            listen(listener) {
                return rootHistory.listen(({ location, action }) => listener(location, action));
            },
        };
    }
    get rootLocation() {
        return this.rootHistory.location;
    }
    push(historyKey, consumerLocation) {
        const { pathname, search, hash, state } = this.createRootLocation(historyKey, consumerLocation);
        this.rootHistory.push({ pathname, search, hash }, state);
    }
    replace(historyKey, consumerLocation) {
        const { pathname, search, hash, state } = this.createRootLocation(historyKey, consumerLocation);
        this.rootHistory.replace({ pathname, search, hash }, state);
    }
    createHref(historyKey, consumerLocation) {
        const { pathname, search, hash } = this.createRootLocation(historyKey, consumerLocation);
        return this.rootHistory.createHref({ pathname, search, hash });
    }
    getConsumerLocation(historyKey) {
        var _a;
        const consumerPath = this.rootLocationTransformer.getConsumerPathFromRootLocation(this.rootLocation, historyKey) || '/';
        const { state, key } = ((_a = this.rootLocation.state) === null || _a === void 0 ? void 0 : _a[historyKey]) || {
            state: undefined,
            key: createKey(),
        };
        return Object.assign(Object.assign({}, createHistoryPath(history.parsePath(consumerPath))), { state,
            key });
    }
    listenForRootLocationChange(listener) {
        return this.rootHistory.listen(({ action }) => {
            listener(action);
        });
    }
    createNewRootLocationForMultipleConsumers(...consumerLocations) {
        let newRootLocation = { pathname: '/' };
        if (this.rootLocationTransformer.createNewRootLocationForMultipleConsumers) {
            newRootLocation =
                this.rootLocationTransformer.createNewRootLocationForMultipleConsumers(...consumerLocations);
        }
        else {
            for (const consumerLocation of consumerLocations) {
                newRootLocation = this.rootLocationTransformer.createRootLocation(newRootLocation, consumerLocation.location, consumerLocation.historyKey);
            }
        }
        const consumerStates = {};
        for (const { historyKey, state } of consumerLocations) {
            consumerStates[historyKey] = { state, key: createKey() };
        }
        return Object.assign(Object.assign({}, createHistoryPath(newRootLocation)), { state: consumerStates });
    }
    createRootLocation(historyKey, consumerLocation) {
        const newRootLocation = this.rootLocationTransformer.createRootLocation(this.rootLocation, consumerLocation, historyKey);
        const { state, key = createKey() } = consumerLocation;
        return Object.assign(Object.assign({}, createHistoryPath(newRootLocation)), { state: Object.assign(Object.assign({}, this.rootLocation.state), { [historyKey]: { state, key } }) });
    }
}
//# sourceMappingURL=history-multiplexer.js.map