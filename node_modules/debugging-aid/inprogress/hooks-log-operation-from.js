'use strict'
const asyncHooks = require('async_hooks')
const filePath = process.argv[1]

function printMessage (message) {
  process._rawDebug(message)
}
function getLocation (stack) {
  const frames = stack.split('\n').slice(2) // skip the error and self
  return frames.find((f) => f.includes('(/')) + ' FROM ' + frames.find((f) => f.includes(filePath)) // This is the interesitn part. The idea is to take the current thing from the stack and then add the closest caller from our own codebase
  // return (frames.find((f) => f.includes("(/")) ? stack: null)
}
// }

const data = new Map()

Error.stackTraceLimit = Math.max(Error.stackTraceLimit, 20)
const asyncHook = asyncHooks.createHook({
  init (asyncId, type, triggerAsyncId) {
    const e = {}
    Error.captureStackTrace(e)
    const location = getLocation(e.stack)
    if (location) {
      data.set(asyncId, { location, triggerAsyncId })
    }
  },

  // before (asyncId) {
  //   const info = data.get(asyncId)
  //   if (!info) return
  //   printMessage(`b [${info.triggerAsyncId}->${asyncId}] ${info.location}`)

  // },

  after (asyncId) {
    const info = data.get(asyncId)
    if (!info) return
    printMessage(`a [${info.triggerAsyncId}->${asyncId}] ${info.location}`)
  }
// TODO add destroy to clean up data in case node reuses sayncIds
})
asyncHook.enable()
